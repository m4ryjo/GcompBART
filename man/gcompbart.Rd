% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gc_functions.R
\name{gcompbart}
\alias{gcompbart}
\title{Performs Bayesian g-computation using SoftBart models to simulate counterfactual outcomes under specified regimes.}
\usage{
gcompbart(
  data,
  var.type,
  fixed.regime = NULL,
  random.regime = NULL,
  param = NULL,
  above = FALSE,
  threshold = NULL,
  nat_value = FALSE,
  incremental = FALSE,
  drop_param = NULL,
  J = 2000,
  opts = NULL,
  Suppress = TRUE,
  By = 100,
  tgroup = rep(1, ncol(data) - 1),
  Lag1 = FALSE,
  num_tree = 20,
  alpha = 1,
  eta = 1,
  phi = rep(1, max(tgroup) - 1),
  alpha_vec = rep(1, max(tgroup) - 1),
  alpha_shape_1 = 0.5,
  BModels = NULL,
  ...
)
}
\arguments{
\item{data}{A matrix or data frame containing confounders, exposures, outcomes, and mortality indicators in temporal order (left to right).}

\item{var.type}{A character vector specifying the type of each variable in `data`. Options: `"X"` (confounder), `"Fi"` (fixed exposure), `"Ra"` (random exposure), `"Y"` (outcome), `"S"` (survival), `"D"` (dropout).}

\item{fixed.regime}{Optional list specifying fixed regimes for exposures or confounders.}

\item{random.regime}{Optional character vector specifying random regime types. Supported: `"uniform"`, `"normal"`, `"triangular"`.}

\item{param}{List of parameter vectors for each random regime. Length depends on regime type: 1 (binomial), 2 (uniform/normal), 3 (triangular).}

\item{above}{Logical. If `TRUE`, applies thresholding above a specified value.}

\item{threshold}{Numeric vector of threshold values for regime application.}

\item{nat_value}{Logical. If `TRUE`, uses natural value regime.}

\item{incremental}{Logical. If `TRUE`, applies incremental regime logic.}

\item{drop_param}{List of parameter vectors for dropout shift modeling using triangular distribution.}

\item{J}{Integer. Size of pseudo data to generate. Default is 2000.}

\item{opts}{List of options passed to SoftBart.}

\item{Suppress}{Logical. If `TRUE`, suppresses console output. Default is `TRUE`.}

\item{By}{Integer. If `Suppress = FALSE`, output is printed every `By` iterations.}

\item{tgroup}{Integer vector indicating time grouping for each variable. Use `0` for static variables and positive integers for time-varying ones.}

\item{Lag1}{Logical. If `TRUE`, applies lag structure to time-varying variables.}

\item{num_tree}{Integer. Number of trees in SoftBart. Default is 20.}

\item{alpha}{Numeric. Prior parameter for SoftBart.}

\item{eta}{Numeric. Prior parameter for SoftBart.}

\item{phi}{Numeric vector. Prior scale parameters for SoftBart.}

\item{alpha_vec}{Numeric vector. Prior shape parameters for SoftBart.}

\item{alpha_shape_1}{Numeric. Prior shape parameter for SoftBart.}

\item{BModels}{Optional list of pre-fitted SoftBart models.}

\item{...}{Additional arguments passed to internal functions.}
}
\value{
A named list containing:
\describe{
  \item{summary_out}{Posterior summaries of predicted outcomes.}
  \item{y_hat}{Posterior samples of predicted outcomes.}
  \item{summary_surv}{Posterior summaries of survival probabilities.}
  \item{s_hat}{Posterior samples of survival probabilities.}
}
}
\description{
Performs Bayesian g-computation using SoftBart models to simulate counterfactual outcomes under specified regimes.
}
\examples{
\dontrun{
n_burn <- 10
n_thin <- 1
n_save <- 10
n_J <- 100

set.seed(1234)

# Simulate dataset
n <- 100
times_sim <- rep(1:4, each = 5)
lambda <- c(0.25, 0.5, 0.75, 1)
a1 <- 0.4; a2 <- 0.2; a3 <- 0.1; sig <- 10

Sig <- matrix(c(...), 20, 20, byrow = TRUE) # truncated for brevity

vartype_bl <- c(rep("X0", 5), rep("X", 15), "Y")
tgroup <- c(rep(1:4, each = 5), 4)

training_data <- sim_lfried(n, 20, Sig, sig, lambda)

# Fit the model
BM <- BMfits(training_data[, 1:21],
             var.type = vartype_bl,
             opts = Opts(num_burn = n_burn, num_thin = n_thin, num_save = n_save,
                         update_s = TRUE, update_alpha = TRUE, update_tau = TRUE,
                         update_sigma_mu = TRUE),
             tgroup = tgroup)

# Perform g-computation
out_gcomp <- gcompbart(training_data[, 1:21],
                       BModels = BM,
                       var.type = vartype_bl,
                       J = n_J,
                       opts = Opts(num_burn = n_burn, num_thin = n_thin, num_save = n_save,
                                   update_s = TRUE, update_alpha = TRUE, update_tau = TRUE,
                                   update_sigma_mu = TRUE),
                       tgroup = tgroup)

# Results
out_gcomp$summary_out
}
}
