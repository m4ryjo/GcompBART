% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gc_functions.R
\name{gcompbart}
\alias{gcompbart}
\title{Performs Bayesian g-computation using SoftBart models to simulate counterfactual outcomes under specified regimes.}
\usage{
gcompbart(
  data,
  var.type,
  fixed.regime = NULL,
  random.regime = NULL,
  param = NULL,
  above = FALSE,
  threshold = NULL,
  nat_value = FALSE,
  incremental = FALSE,
  drop_param = NULL,
  J = 2000,
  opts = NULL,
  Suppress = TRUE,
  By = 100,
  tgroup = rep(1, ncol(data) - 1),
  Lag1 = FALSE,
  base_hypers = NULL,
  BModels = NULL,
  ...
)
}
\arguments{
\item{data}{A matrix or data frame containing confounders, exposures, outcomes, and mortality indicators in temporal order (left to right).}

\item{var.type}{A character vector specifying the type of each variable in `data`. Options: `"X"` (confounder), `"Fi"` (fixed exposure), `"Ra"` (random exposure), `"Y"` (outcome), `"S"` (survival), `"D"` (dropout).}

\item{fixed.regime}{Optional list specifying fixed regimes for exposures or confounders.}

\item{random.regime}{Optional character vector specifying random regime types. Supported: `"uniform"`, `"normal"`, `"triangular"`.}

\item{param}{List of parameter vectors for each random regime. Length depends on regime type: 1 (binomial), 2 (uniform/normal), 3 (triangular).}

\item{above}{Logical. If `TRUE`, applies thresholding above a specified value.}

\item{threshold}{Numeric vector of threshold values for regime application.}

\item{nat_value}{Logical. If `TRUE`, uses natural value regime.}

\item{incremental}{Logical. If `TRUE`, applies incremental regime logic.}

\item{drop_param}{List of parameter vectors for dropout shift modeling using triangular distribution.}

\item{J}{Integer. Size of pseudo data to generate. Default is 2000.}

\item{opts}{List of options. Default is NULL.}

\item{Suppress}{Logical. If `TRUE`, suppresses console output. Default is `TRUE`.}

\item{By}{Integer. If `Suppress = FALSE`, output is printed every `By` iterations.}

\item{tgroup}{Integer vector indicating time grouping for each variable. Use `0` for static variables and positive integers for time-varying ones.}

\item{Lag1}{Logical. If `TRUE`, applies lag structure to time-varying variables.}

\item{base_hypers}{List of hypers. Default is NULL.}

\item{BModels}{Optional list of pre-fitted SoftBart models.}

\item{...}{Additional arguments passed to internal functions.}
}
\value{
A named list containing:
\describe{
  \item{summary_out}{Posterior summaries of predicted outcomes.}
  \item{y_hat}{Posterior samples of predicted outcomes.}
  \item{summary_surv}{Posterior summaries of survival probabilities.}
  \item{s_hat}{Posterior samples of survival probabilities.}
}
}
\description{
Performs Bayesian g-computation using SoftBart models to simulate counterfactual outcomes under specified regimes.
}
\note{
Future versions will include an optional argument `return_full = TRUE`
to return additional objects such as model options (`opts`), hyperparameters
(`base_hypers`), and diagnostics for model fit.
}
\examples{
\dontrun{
n_burn <- 10
n_thin <- 1
n_save <- 10
n_J <- 100

set.seed(123)

# Simulate dataset
training_data <- sim_lfried(N = 100, n_time = 4, lags = c(0.4, 0.2, 0.1),
                  sigma = 1, lambda = c(0.25, 0.5, 0.75, 1))
vartype_bl <- c(rep("X0", 5), rep("X", 15), "Y")
tgroup <- c(rep(1:4, each = 5), 4)

# Fit the model
BM <- BMfits(training_data[, 1:21],
             var.type = vartype_bl,
             opts = Opts(num_burn = n_burn, num_thin = n_thin, num_save = n_save,
                         update_s = TRUE, update_alpha = TRUE, update_tau = TRUE,
                         update_sigma_mu = TRUE),
             tgroup = tgroup)

# Perform g-computation
out_gcomp <- gcompbart(training_data[, 1:21],
                       BModels = BM,
                       var.type = vartype_bl,
                       J = n_J,
                       opts = Opts(num_burn = n_burn, num_thin = n_thin, num_save = n_save,
                                   update_s = TRUE, update_alpha = TRUE, update_tau = TRUE,
                                   update_sigma_mu = TRUE),
                       tgroup = tgroup)

# Results
out_gcomp$summary_out
}
}
