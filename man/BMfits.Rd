% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gc_functions.R
\name{BMfits}
\alias{BMfits}
\title{BMfits}
\usage{
BMfits(
  data,
  var.type,
  fixed.regime = NULL,
  random.regime = NULL,
  param = NULL,
  above = FALSE,
  threshold = NULL,
  nat_value = FALSE,
  incremental = FALSE,
  drop_param = NULL,
  J = 2000,
  opts = NULL,
  Suppress = TRUE,
  By = 100,
  tgroup = rep(1, ncol(data) - 1),
  Lag1 = FALSE,
  base_hypers = NULL,
  ...
)
}
\arguments{
\item{data}{A matrix or data frame containing variables in temporal order: confounders, exposures, outcomes, survival, and dropout indicators.}

\item{var.type}{A character vector specifying the type of each variable in `data`. Options: `"X"` (confounder), `"Fi"` (fixed exposure), `"Ra"` (random exposure), `"Y"` (outcome), `"S"` (survival), `"D"` (dropout).}

\item{fixed.regime}{Optional specification for fixed treatment regime.}

\item{random.regime}{Optional specification for random treatment regime.}

\item{param}{Optional parameter vector for regime specification.}

\item{above}{Logical; indicates if regime applies above a threshold.}

\item{threshold}{Numeric threshold for regime application.}

\item{nat_value}{Logical; if TRUE, uses natural value regime.}

\item{incremental}{Logical; if TRUE, applies incremental regime.}

\item{drop_param}{Optional parameter for dropout modeling.}

\item{J}{Integer; number of MCMC iterations (default = 2000).}

\item{opts}{List of options passed to SoftBart.}

\item{Suppress}{Logical; if TRUE, suppresses console output (default = TRUE).}

\item{By}{Integer; if `Suppress = FALSE`, output is printed every `By` iterations.}

\item{tgroup}{Integer vector indicating time grouping for each variable. Use `0` for static variables and positive integers for time-varying ones.}

\item{Lag1}{Logical; if TRUE, applies lag structure to time-varying variables.}

\item{base_hypers}{A list of base hyperparameters.}

\item{...}{Additional arguments passed to internal modeling functions.}
}
\value{
A list containing:
\describe{
  \item{BModels}{List of fitted Bayesian models for each variable.}
  \item{n_Y}{Number of outcome variables.}
  \item{n_S}{Number of survival variables.}
  \item{n_Reg}{Number of regimes (if applicable).}
  \item{num_save}{Number of saved iterations.}
  \item{continuous}{Continuous variables.}
  \item{iterations}{Number of iterations.}
  \item{...}{Other metadata needed for `gcompbart()`.}
}
}
\description{
Fits Bayesian models (e.g., SoftBart) for each variable in the data according to its type and temporal structure. The fitted models are used in subsequent g-computation via `gcompbart()`.
}
\note{
Future versions will include an optional argument `return_full = TRUE`
to return additional objects such as model options (`opts`), hyperparameters
(`base_hypers`), and diagnostics for model fit.
}
\examples{
\dontrun{
n_burn <- 10
n_thin <- 1
n_save <- 10
n_J <- 100

set.seed(1234)

# Simulate dataset
n <- 100
times_sim <- rep(1:4, each = 5)
lambda <- c(0.25, 0.5, 0.75, 1)
a1 <- 0.4; a2 <- 0.2; a3 <- 0.1; sig <- 10

Sig <- matrix(c(...), 20, 20, byrow = TRUE) # truncated for brevity

vartype_bl <- c(rep("X0", 5), rep("X", 15), "Y")
tgroup <- c(rep(1:4, each = 5), 4)

training_data <- sim_lfried(n, 20, Sig, sig, lambda)

# Fit the model
BM <- BMfits(training_data[, 1:21],
             var.type = vartype_bl,
             opts = Opts(num_burn = n_burn, num_thin = n_thin, num_save = n_save,
                         update_s = TRUE, update_alpha = TRUE, update_tau = TRUE,
                         update_sigma_mu = TRUE),
             tgroup = tgroup)

# Perform g-computation
out_gcomp <- gcompbart(training_data[, 1:21],
                       BModels = BM,
                       var.type = vartype_bl,
                       J = n_J,
                       opts = Opts(num_burn = n_burn, num_thin = n_thin, num_save = n_save,
                                   update_s = TRUE, update_alpha = TRUE, update_tau = TRUE,
                                   update_sigma_mu = TRUE),
                       tgroup = tgroup)

# Results
out_gcomp$summary_out
}
}
